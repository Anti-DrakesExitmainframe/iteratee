package io.iteratee

import cats.Eval
import io.iteratee.tests.{ EvalSuite, EnumerateeSuite, StackSafeEnumeratorSuite, IterateeSuite }

class EvalEnumerateeTests extends EnumerateeSuite[Eval] with EvalSuite {
  "take" should "work with more than Int.MaxValue values" in forAll { (n: Int) =>
    val items = Vector.fill(1000000)(())
    val totalSize: Long = Int.MaxValue.toLong + math.max(1, n).toLong
    val enumerator = repeat(()).flatMap(_ => enumVector(items)).through(take(totalSize))

    assert(enumerator.into(length) === F.pure(totalSize))
  }
}

class EvalEnumeratorTests extends StackSafeEnumeratorSuite[Eval] with EvalSuite {
  "perform" should "perform an action" in forAll { (eav: EnumeratorAndValues[Int]) =>
    var counter = 0
    val action = perform[Int](Eval.always(counter += 1))
    val enumerator = action.append(eav.enumerator).append(action)

    assert(counter === 0)
    assert(enumerator.toVector === Eval.now(eav.values))
    assert(counter === 2)
  }

  "generateM" should "enumerate values generated by an effectful function" in forAll { (n: Short) =>
    val count = math.abs(n.toInt)
    var counter = 0
    val enumerator = generateM(
      Eval.always(
        if (counter > count) None else Some {
          val result = counter
          counter += 1
          result
        }
      )
    )

    assert(enumerator.toVector === Eval.now((0 to count).toVector))
    assert(counter == count + 1)
  }
}

class EvalIterateeTests extends IterateeSuite[Eval] with EvalSuite
